# agents/credit_appraisal/agent.py
from __future__ import annotations

import json
import math
import random
from typing import Dict, Any, List, Tuple, Optional

import numpy as np
import pandas as pd

from .model_utils import ensure_model, FEATURES

def _safe_num(x, default=0.0):
    try:
        return float(x)
    except Exception:
        return default

def _ensure_minimal_schema(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()

    # Harmonize columns UI might have precomputed
    if "employment_years" not in out.columns and "employment_length" in out.columns:
        out["employment_years"] = out["employment_length"]
    if "debt_to_income" not in out.columns:
        if "DTI" in out.columns:
            out["debt_to_income"] = out["DTI"]
        elif "existing_debt" in out.columns and "income" in out.columns:
            inc = out["income"].replace(0, np.nan)
            out["debt_to_income"] = (out.get("existing_debt", 0) / inc).fillna(0.0)
        else:
            out["debt_to_income"] = 0.0
    if "credit_history_length" not in out.columns:
        out["credit_history_length"] = 0
    if "num_delinquencies" not in out.columns:
        out["num_delinquencies"] = 0
    if "current_loans" not in out.columns:
        out["current_loans"] = 0
    if "loan_term_months" not in out.columns and "loan_duration_months" in out.columns:
        out["loan_term_months"] = out["loan_duration_months"]
    if "requested_amount" not in out.columns and "loan_amount" in out.columns:
        out["requested_amount"] = out["loan_amount"]

    # Derived helpers
    eps = 1e-9
    if "LTV" not in out.columns and {"loan_amount","collateral_value"}.issubset(out.columns):
        out["LTV"] = (out["loan_amount"] / (out["collateral_value"] + eps)).clip(0, 10)

    return out

def _top_feature_by_coef(model, row: pd.Series) -> Tuple[str, float]:
    # quick proxy: largest |coef * value|
    if not hasattr(model, "coef_"):
        return "", 0.0
    vals = []
    for i, f in enumerate(FEATURES):
        v = _safe_num(row.get(f), 0.0)
        c = float(model.coef_[0][i]) if hasattr(model, "coef_") else 0.0
        vals.append((f, abs(c * v)))
    vals.sort(key=lambda x: x[1], reverse=True)
    return vals[0] if vals else ("", 0.0)

def _classic_rules(row: pd.Series, cfg: Dict[str, Any]) -> Tuple[bool, Dict[str, bool], Optional[Dict[str, Any]]]:
    rc = cfg["classic"]
    reasons = {}

    dti = _safe_num(row.get("debt_to_income"))
    emp = _safe_num(row.get("employment_years"))
    ch  = _safe_num(row.get("credit_history_length"))
    delinq = _safe_num(row.get("num_delinquencies"))
    cur_loans = _safe_num(row.get("current_loans"))
    req_amt = _safe_num(row.get("requested_amount") or row.get("loan_amount"))
    term = int(row.get("loan_term_months") or row.get("loan_duration_months") or 0)
    income = _safe_num(row.get("income"))
    ltv = _safe_num(row.get("LTV"))
    collat = _safe_num(row.get("collateral_value"))

    reasons["emp_years_ok"] = (emp >= rc["min_employment_years"])
    reasons["credit_hist_ok"] = (ch >= rc["min_credit_history_length"])
    reasons["dti_ok"] = (dti <= rc["max_debt_to_income"])
    reasons["delinq_ok"] = (delinq <= rc["max_num_delinquencies"])
    reasons["cur_loans_ok"] = (cur_loans <= rc["max_current_loans"])
    reasons["salary_floor_ok"] = (income >= rc["salary_floor"])
    reasons["req_range_ok"] = (rc["requested_amount_min"] <= req_amt <= rc["requested_amount_max"])
    reasons["term_allowed_ok"] = (term in rc["loan_term_months_allowed"])

    # Debt pressure controls
    compounded_debt = req_amt * rc["compounded_debt_factor"] - rc["monthly_debt_relief"] * (term / 12.0) * 12.0
    compounded_debt = max(compounded_debt, 0.0)
    reasons["income_debt_ratio_ok"] = (income / (compounded_debt + 1e-9) >= rc["min_income_debt_ratio"])

    # Aggregate decision (rules-only). Model score combined later.
    passed_rules = all(reasons.values())

    # propose a loan option if approve-ish
    proposed = None
    if passed_rules:
        # choose the nearest allowed term with simple heuristic
        allowed = rc["loan_term_months_allowed"]
        near_term = term if term in allowed else (min(allowed, key=lambda t: abs(t - (term or 36))) if allowed else 36)
        apr = 0.12 if dti < 0.2 else 0.18 if dti < 0.4 else 0.25
        proposed = {
            "term_months": int(near_term),
            "apr": round(apr, 4),
            "amount": float(req_amt),
        }

    return passed_rules, reasons, proposed

def _ndi_rules(row: pd.Series, cfg: Dict[str, Any]) -> Tuple[bool, Dict[str, bool], Optional[Dict[str, Any]]]:
    rn = cfg["ndi"]
    income = _safe_num(row.get("income"))
    # approximate monthly obligations: DTI*income
    dti = _safe_num(row.get("debt_to_income"))
    nda = income * (1.0 - dti)
    ndi_ratio = 0.0 if income <= 0 else (nda / income)

    reasons = {
        "ndi_value_ok": (nda >= rn["ndi_value"]),
        "ndi_ratio_ok": (ndi_ratio >= rn["ndi_ratio"]),
    }
    passed_rules = all(reasons.values())

    proposed = None
    if passed_rules:
        # simple plan derived from affordability
        req_amt = _safe_num(row.get("requested_amount") or row.get("loan_amount"))
        term = int(row.get("loan_term_months") or 36)
        apr = 0.15 if ndi_ratio > 0.6 else 0.22
        proposed = {"term_months": term, "apr": round(apr, 4), "amount": req_amt}

    return passed_rules, reasons, proposed

def _propose_consolidation(row: pd.Series) -> Optional[Dict[str, Any]]:
    # Create a simple consolidation/buyback proposal if existing debts/loans present
    existing = _safe_num(row.get("existing_debt", 0.0))
    current_loans = int(row.get("current_loans", 0))
    req_amt = _safe_num(row.get("requested_amount") or row.get("loan_amount"))
    if existing <= 0 and current_loans <= 0:
        return None
    # Propose to consolidate existing into a single plan with the new request reduced by 15%
    combined = max(existing + req_amt * 0.85, 0.0)
    term = int(row.get("loan_term_months") or 36)
    proposal = {
        "consolidated_amount": round(combined, 2),
        "term_months": term + 12,
        "apr": 0.19,
        "note": "Refinance current loans/debt and reduce requested amount by 15% to fit affordability.",
    }
    return proposal

def _apply_threshold(scores: np.ndarray, cfg: Dict[str, Any]) -> float:
    # threshold or target rate band
    thr = None
    if cfg["rule_mode"] == "classic":
        thr = cfg["classic"].get("threshold")
        target = cfg["classic"].get("target_approval_rate")
        rnd = cfg["classic"].get("random_band", True)
    else:
        thr = cfg["ndi"].get("threshold")
        target = cfg["ndi"].get("target_approval_rate")
        rnd = cfg["ndi"].get("random_band", True)

    if target is not None:
        # choose percentile as threshold; add slight randomness if requested
        pct = 100 * (1.0 - float(target))
        base = np.percentile(scores, pct)
        if rnd:
            base *= (0.8 + 0.4 * random.random())
        return float(base)

    if thr is None:
        # default band when nothing specified
        base = 0.4
        if rnd:
            base *= (0.8 + 0.4 * random.random())
        return float(base)
    return float(thr)

def run_credit_appraisal(df: pd.DataFrame, cfg: Dict[str, Any], run_dir: Optional[str] = None) -> Dict[str, Any]:
    df = _ensure_minimal_schema(df)
    # Train/load model
    model, feats = ensure_model(df, force_fit=False, label_col="label")

    # Scoring
    X = df.copy()
    for f in feats:
        if f not in X.columns:
            X[f] = 0.0
    X = X[feats].astype(float)
    probs = model.predict_proba(X.to_numpy())[:, 1]

    # Apply rule mode per row + combine with score threshold
    rows: List[Dict[str, Any]] = []
    scores_rows: List[Dict[str, Any]] = []
    expl_rows: List[Dict[str, Any]] = []

    thr = _apply_threshold(probs, cfg)

    for i, row in df.iterrows():
        rule_ok: bool
        rule_reasons: Dict[str, bool]
        proposed: Optional[Dict[str, Any]]

        if cfg["rule_mode"] == "classic":
            rule_ok, rule_reasons, proposed = _classic_rules(row, cfg)
        else:
            rule_ok, rule_reasons, proposed = _ndi_rules(row, cfg)

        score = float(probs[i])
        decision = "approved" if (score >= thr and rule_ok) else "denied"

        cons = None
        if decision == "denied":
            cons = _propose_consolidation(row)

        # quick explanation feature
        tf, tf_val = _top_feature_by_coef(model, row)
        explanation = f"Top factor: {tf}"

        rows.append({
            "application_id": row.get("application_id", f"row_{i}"),
            "decision": decision,
            "score": score,
            "loan_amount": row.get("loan_amount"),
            "income": row.get("income"),
            "DTI": row.get("debt_to_income"),
            "LTV": row.get("LTV"),
            "collateral_type": row.get("collateral_type"),
            "collateral_value": row.get("collateral_value"),
            "customer_type": row.get("customer_type", "bank"),
            "requested_amount": row.get("requested_amount", row.get("loan_amount")),
            "loan_term_months": row.get("loan_term_months", row.get("loan_duration_months")),
            "proposed_loan_option": json.dumps(proposed) if proposed else None,
            "proposed_consolidation_loan": json.dumps(cons) if cons else None,
            "rule_reasons": json.dumps(rule_reasons),
            "top_feature": tf,
            "explanation": explanation,
            "currency_code": cfg.get("currency_code", "USD"),
        })

        scores_rows.append({
            "application_id": row.get("application_id", f"row_{i}"),
            "score": score,
        })
        expl_rows.append({
            "application_id": row.get("application_id", f"row_{i}"),
            "top_feature": tf,
            "value": tf_val,
            "explanation": explanation,
        })

    merged = pd.DataFrame(rows)
    scores = pd.DataFrame(scores_rows)
    expl   = pd.DataFrame(expl_rows)

    summary = {
        "n_rows": int(len(merged)),
        "approved": int((merged["decision"] == "approved").sum()),
        "denied": int((merged["decision"] == "denied").sum()),
        "threshold": float(thr),
        "rule_mode": cfg["rule_mode"],
        "currency_code": cfg.get("currency_code", "USD"),
    }

    return {
        "merged": merged,
        "scores": scores,
        "explanations": expl,
        "summary": summary
    }
