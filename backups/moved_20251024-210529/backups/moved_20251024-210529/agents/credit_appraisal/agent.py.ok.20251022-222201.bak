# agents/credit_appraisal/agent.py
from __future__ import annotations
import os
import json
import math
from typing import Dict, Any
import pandas as pd
import numpy as np
from fpdf import FPDF

from .model_utils import ensure_production_model, predict_proba, FEATURES

def _coerce_numeric(df: pd.DataFrame, cols: list[str]) -> pd.DataFrame:
    out = df.copy()
    for c in cols:
        if c not in out.columns:
            out[c] = 0
        out[c] = pd.to_numeric(out[c], errors="coerce").fillna(0.0)
    return out

def _rule_check_row(row: pd.Series, rules: Dict[str, Any]) -> tuple[bool, Dict[str, bool]]:
    mode = (rules.get("mode") or "classic").lower()
    reasons: Dict[str, bool] = {}

    # shared fields
    income = float(row.get("income", 0))
    req_amount = float(row.get("requested_amount", row.get("loan_amount", 0)))
    dti = float(row.get("debt_to_income", 0))
    emp_years = float(row.get("employment_years", row.get("employment_length", 0)))
    credit_hist = float(row.get("credit_history_length", 0))
    delinq = float(row.get("num_delinquencies", 0))
    current_loans = float(row.get("current_loans", 0))
    loan_term = float(row.get("loan_term_months", row.get("loan_duration_months", 0)))
    credit_score = float(row.get("credit_score", 0))
    collateral_value = float(row.get("collateral_value", 0))

    if mode == "ndi":
        nd = rules.get("ndi", {})
        ndi_val = float(row.get("income", 0)) - float(row.get("monthly_expenses", 0)) - float(row.get("monthly_debt_payments", 0))
        ndi_ratio = 0.0
        if income > 0:
            ndi_ratio = ndi_val / income
        reasons["ndi_value_ok"] = ndi_val >= float(nd.get("ndi_value", 800))
        reasons["ndi_ratio_ok"] = ndi_ratio >= float(nd.get("ndi_ratio", 0.5))
        ok = all(reasons.values())
        return ok, reasons

    # classic
    cl = rules.get("classic", {})
    reasons["max_dti_ok"] = dti <= float(cl.get("max_dti", 0.45))
    reasons["min_emp_years_ok"] = emp_years >= float(cl.get("min_emp_years", 2))
    reasons["min_credit_hist_ok"] = credit_hist >= float(cl.get("min_credit_hist", 3))
    reasons["salary_floor_ok"] = (income / 12.0) >= float(cl.get("salary_floor", 3000)) if income > 0 else False
    reasons["max_delinquencies_ok"] = delinq <= float(cl.get("max_delinquencies", 2))
    reasons["max_current_loans_ok"] = current_loans <= float(cl.get("max_current_loans", 3))
    reasons["req_range_ok"] = (float(cl.get("req_min", 1000)) <= req_amount <= float(cl.get("req_max", 200000)))
    # allowed terms
    terms = cl.get("loan_terms") or [12, 24, 36, 48, 60]
    reasons["term_allowed_ok"] = int(loan_term or 0) in set(terms)

    # debt pressure
    compounded_debt = float(cl.get("compounded_debt_factor", 1.0)) * max(req_amount, 0)
    denom = (float(cl.get("monthly_debt_relief", 0.5)) * max(income, 0)) + 1e-9
    debt_ratio = (compounded_debt / denom) if denom > 0 else math.inf
    reasons["income_debt_ratio_ok"] = (float(cl.get("min_income_debt_ratio", 0.35)) <= (income / (compounded_debt + 1e-9)))

    # soft credit score gate (more lenient than model)
    reasons["credit_score_soft_ok"] = credit_score >= 550

    ok = all(reasons.values())
    return ok, reasons

def _propose_loan(row: pd.Series, approved: bool) -> str:
    # Serialize simple plan JSON string
    amt = float(row.get("requested_amount", row.get("loan_amount", 0)))
    term = int(row.get("loan_term_months", row.get("loan_duration_months", 0)) or 36)
    if approved:
        rate = 0.12 if amt < 20000 else 0.10
        monthly = (amt * (1 + rate)) / max(term, 12)
        plan = {"type": "standard", "amount": round(amt, 2), "term_months": term, "apr": rate, "est_monthly": round(monthly, 2)}
        return json.dumps(plan)
    return ""

def _propose_consolidation(row: pd.Series) -> str:
    # If denied and has current_loans>0 and decent collateral, suggest consolidation
    current_loans = float(row.get("current_loans", 0))
    collateral_value = float(row.get("collateral_value", 0))
    existing_debt = float(row.get("existing_debt", 0))
    income = float(row.get("income", 0))
    if current_loans <= 0 or collateral_value <= 0 or existing_debt <= 0:
        return ""
    # simple proposal: consolidate all existing debt into one longer term
    term = 48 if income < 50000 else 36
    rate = 0.14 if income < 50000 else 0.12
    monthly = (existing_debt * (1 + rate)) / term
    plan = {
        "type": "consolidation",
        "consolidate_amount": round(existing_debt, 2),
        "term_months": term,
        "apr": rate,
        "est_monthly": round(monthly, 2),
        "secured_by": "collateral" if collateral_value > existing_debt * 0.5 else "unsecured",
    }
    return json.dumps(plan)

def _write_pdf(path: str, summary: dict):
    try:
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font("Arial", "B", 16)
        pdf.cell(0, 10, "Credit Appraisal Report", ln=True)
        pdf.set_font("Arial", "", 12)
        for k, v in summary.items():
            pdf.cell(0, 8, f"{k}: {v}", ln=True)
        pdf.output(path)
    except Exception:
        # Silent fail; UI can still use CSV/JSON
        pass

def run_credit_appraisal(df: pd.DataFrame, run_dir: str, rules: Dict[str, Any], settings: Dict[str, Any]) -> dict:
    os.makedirs(run_dir, exist_ok=True)

    # Ensure production model
    model = ensure_production_model(df_hint=df)

    # Prepare input features
    df = df.copy()
    # Harmonize key names expected by features
    if "employment_years" not in df.columns and "employment_length" in df.columns:
        df["employment_years"] = df["employment_length"]
    if "requested_amount" not in df.columns and "loan_amount" in df.columns:
        df["requested_amount"] = df["loan_amount"]
    if "loan_term_months" not in df.columns and "loan_duration_months" in df.columns:
        df["loan_term_months"] = df["loan_duration_months"]
    if "debt_to_income" not in df.columns:
        if "existing_debt" in df.columns and "income" in df.columns:
            df["debt_to_income"] = (pd.to_numeric(df["existing_debt"], errors="coerce").fillna(0.0) /
                                    (pd.to_numeric(df["income"], errors="coerce").fillna(0.0) + 1e-9)).clip(0, 10)
        else:
            df["debt_to_income"] = 0.0

    # Score with model
    probs = predict_proba(model, df)
    df_scores = pd.DataFrame({
        "application_id": df.get("application_id", pd.Series(range(len(df)))),
        "score": probs,
    })
    df_scores.to_csv(os.path.join(run_dir, "scores.csv"), index=False)

    # Decide threshold/target
    thr = rules.get("threshold")
    target_rate = rules.get("target_rate")
    if thr is None and target_rate is not None:
        # choose threshold to hit approximate target approve rate
        s = np.sort(probs)[::-1]
        k = max(1, int(target_rate * len(s)))
        thr = float(s[k-1]) if len(s) else 0.5
    if thr is None:
        thr = 0.45

    # Row-wise rules + decisions
    decisions = []
    explanations = []
    for i, row in df.iterrows():
        score = float(probs[i])
        rule_ok, reasons = _rule_check_row(row, rules)
        approved = (score >= thr) and rule_ok
        decisions.append("approved" if approved else "denied")
        explanations.append({
            "application_id": row.get("application_id", i),
            "top_feature": "credit_score_vs_dti",
            "explanation": f"Score={score:.3f} with DTI={row.get('debt_to_income',0):.2f} and CS={row.get('credit_score',0)}",
            "rule_reasons": json.dumps(reasons),
        })
    df_dec = pd.DataFrame({"application_id": df.get("application_id", pd.Series(range(len(df)))), "decision": decisions})
    df_expl = pd.DataFrame(explanations)

    # Proposed plans
    loan_opts, consolidation_opts = [], []
    for i, row in df.iterrows():
        appr = decisions[i] == "approved"
        loan_opts.append(_propose_loan(row, appr))
        consolidation_opts.append(_propose_consolidation(row) if not appr else "")
    df_extra = pd.DataFrame({
        "application_id": df.get("application_id", pd.Series(range(len(df)))),
        "proposed_loan_option": loan_opts,
        "proposed_consolidation_loan": consolidation_opts,
    })

    # merged
    merged = df.copy()
    merged["application_id"] = merged.get("application_id", pd.Series(range(len(merged))))
    merged = merged.merge(df_scores, on="application_id", how="left") \
                   .merge(df_dec, on="application_id", how="left") \
                   .merge(df_expl, on="application_id", how="left") \
                   .merge(df_extra, on="application_id", how="left")
    merged.to_csv(os.path.join(run_dir, "merged.csv"), index=False)

    # explanations.csv (flat)
    flat_expl = df_expl.copy()
    # Ensure rule_reasons stays serialized string (UI parses to met/unmet)
    flat_expl.to_csv(os.path.join(run_dir, "explanations.csv"), index=False)

    # Summary JSON
    summary = {
        "count": int(len(merged)),
        "approved": int((merged["decision"] == "approved").sum()) if "decision" in merged.columns else 0,
        "denied": int((merged["decision"] == "denied").sum()) if "decision" in merged.columns else 0,
        "threshold_used": float(thr),
        "target_rate_used": float(target_rate) if target_rate is not None else None,
    }
    with open(os.path.join(run_dir, "summary.json"), "w") as f:
        json.dump(summary, f, indent=2)

    # Minimal PDF report
    _write_pdf(os.path.join(run_dir, "report.pdf"), summary)

    return {
        "summary": summary,
        "paths": {
            "scores": "scores.csv",
            "explanations": "explanations.csv",
            "merged": "merged.csv",
            "summary": "summary.json",
            "pdf": "report.pdf",
        },
    }

