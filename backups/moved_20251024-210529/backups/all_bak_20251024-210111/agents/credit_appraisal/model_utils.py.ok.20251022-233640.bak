# agents/credit_appraisal/model_utils.py
from __future__ import annotations

import json
import os
from typing import List, Optional, Tuple

import joblib
import numpy as np
import pandas as pd
from sklearn.linear_model import LogisticRegression

RUNS_DIR = os.path.expanduser("~/demo-library/services/api/.runs")
MODELS_DIR = os.path.join(RUNS_DIR, "models")
TRAINED_DIR = os.path.join(MODELS_DIR, "trained")
PROD_DIR = os.path.join(MODELS_DIR, "production")
os.makedirs(TRAINED_DIR, exist_ok=True)
os.makedirs(PROD_DIR, exist_ok=True)

# Core feature list (keep small/robust)
FEATURES: List[str] = [
    "income",
    "loan_amount",
    "employment_years",
    "credit_history_length",
    "debt_to_income",  # DTI
    "num_delinquencies",
    "current_loans",
    "collateral_value",
]

def _prepare_features(df: pd.DataFrame) -> pd.DataFrame:
    x = df.copy()
    for c in FEATURES:
        if c not in x.columns:
            x[c] = 0.0
    return x[FEATURES].astype(float)

def _prepare_labels(df: pd.DataFrame, label_col: str) -> Optional[np.ndarray]:
    if label_col not in df.columns:
        return None
    lab = df[label_col]
    if lab.dropna().empty:
        return None
    # Fill missing labels with heuristics if needed (optional)
    y = lab.fillna(0).astype(int).to_numpy()
    return y

def _load_production_model_path() -> Optional[str]:
    path = os.path.join(PROD_DIR, "credit_model.joblib")
    return path if os.path.isfile(path) else None

def load_production_model() -> Optional[LogisticRegression]:
    p = _load_production_model_path()
    if p is None:
        return None
    try:
        return joblib.load(p)
    except Exception:
        return None

def save_candidate_model_meta(job_id: str, meta: dict) -> str:
    meta_path = os.path.join(TRAINED_DIR, f"candidate_job_{job_id}.json")
    joblib_path = os.path.join(TRAINED_DIR, f"candidate_job_{job_id}.joblib")
    # Save only meta here; model saved by ensure_model (below) when force_fit=True
    with open(meta_path, "w", encoding="utf-8") as f:
        json.dump(meta, f, indent=2, ensure_ascii=False)
    # If a fitted model exists in memory, ensure_model will also write joblib there.
    return meta_path

def load_candidate_meta(job_id: str) -> Optional[dict]:
    meta_path = os.path.join(TRAINED_DIR, f"candidate_job_{job_id}.json")
    if not os.path.isfile(meta_path):
        return None
    try:
        with open(meta_path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None

def save_production_model(candidate_joblib_path: str, candidate_meta_path: str) -> None:
    # Copy candidate to production slots
    target_model = os.path.join(PROD_DIR, "credit_model.joblib")
    target_meta = os.path.join(PROD_DIR, "meta.json")
    import shutil
    shutil.copy2(candidate_joblib_path, target_model)
    shutil.copy2(candidate_meta_path, target_meta)

def ensure_model(df: pd.DataFrame, force_fit: bool = False, label_col: str = "label") -> Tuple[LogisticRegression, List[str]]:
    """
    Load production model if exists; else fit a simple logistic regression.
    When force_fit=True, we always fit a candidate into TRAINED_DIR (with a timestamp).
    """
    X = _prepare_features(df) if not df.empty else pd.DataFrame(columns=FEATURES)
    y = _prepare_labels(df, label_col)

    # Try load production when not forcing fit and it exists.
    if not force_fit:
        mdl = load_production_model()
        if mdl is not None:
            return mdl, FEATURES

    # If we have at least some rows, fit; otherwise fit on dummy data
    if X.empty:
        # 2 dummy rows to allow fit without error
        X = pd.DataFrame({c: [0.0, 1.0] for c in FEATURES})
        y = np.array([0, 1])

    if y is None or len(np.unique(y)) < 2:
        # Make a weak synthetic label if no labels
        y = (X["income"].fillna(0) > X["loan_amount"].fillna(0)).astype(int).to_numpy()

    model = LogisticRegression(max_iter=500)
    model.fit(X.to_numpy(), y)

    # If force_fit: save candidate snapshot
    if force_fit:
        ts = str(int(time.time()))
        job_path = os.path.join(TRAINED_DIR, f"candidate_job_{ts}.joblib")
        joblib.dump(model, job_path)

    return model, FEATURES
