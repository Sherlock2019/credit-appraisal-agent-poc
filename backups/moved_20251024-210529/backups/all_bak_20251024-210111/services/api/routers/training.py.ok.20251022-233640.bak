# services/api/routers/training.py
from __future__ import annotations

import glob
import json
import os
import time
from typing import Any, Dict, List, Optional

import pandas as pd
from fastapi import APIRouter, HTTPException
from fastapi.responses import JSONResponse

from agents.credit_appraisal.model_utils import ensure_model, save_production_model, load_candidate_meta, save_candidate_model_meta

RUNS_DIR = os.path.expanduser("~/demo-library/services/api/.runs")
FEEDBACK_DIR = os.path.join(RUNS_DIR, "feedback")
MODELS_DIR = os.path.join(RUNS_DIR, "models")
TRAINED_DIR = os.path.join(MODELS_DIR, "trained")
PROD_DIR = os.path.join(MODELS_DIR, "production")
os.makedirs(FEEDBACK_DIR, exist_ok=True)
os.makedirs(TRAINED_DIR, exist_ok=True)
os.makedirs(PROD_DIR, exist_ok=True)

router = APIRouter()

@router.post("/v1/training/feedback")
def post_feedback(payload: Dict[str, Any]):
    """
    Accepts: {"items":[{"application_id":..., "ai_decision":..., "human_decision":..., "human_rule_reasons": ...}, ...]}
    Appends to a JSONL file under .runs/feedback/feedback_YYYYmmdd.jsonl
    """
    items = payload.get("items") or []
    if not isinstance(items, list) or not items:
        raise HTTPException(400, "no items")

    ts = time.strftime("%Y%m%d")
    path = os.path.join(FEEDBACK_DIR, f"feedback_{ts}.jsonl")
    cnt = 0
    with open(path, "a", encoding="utf-8") as f:
        for it in items:
            f.write(json.dumps(it, ensure_ascii=False) + "\n")
            cnt += 1
    return JSONResponse({"ok": True, "written": cnt, "file": path})

@router.post("/v1/training/train")
def post_train(payload: Dict[str, Any]):
    """
    Trains a candidate model using available feedback + last merged results as weak labels.
    Simplified logic: we read all feedback JSONL, try to join with the latest merged.csv (most recent run),
    and fit a very small model with model_utils.ensure_model() (which trains baseline if no model present).
    """
    # Find the latest merged.csv as base features (fallback if none).
    runs = sorted([d for d in os.listdir(RUNS_DIR) if d.startswith("run_")], reverse=True)
    base_df: Optional[pd.DataFrame] = None
    for r in runs:
        m = os.path.join(RUNS_DIR, r, "merged.csv")
        if os.path.isfile(m):
            try:
                base_df = pd.read_csv(m)
                break
            except Exception:
                continue

    if base_df is None or base_df.empty:
        # Fallback to a tiny synthetic-like structure: ensure_model can bootstrap.
        base_df = pd.DataFrame()

    # Load feedback rows
    rows: List[Dict[str, Any]] = []
    for path in glob.glob(os.path.join(FEEDBACK_DIR, "feedback_*.jsonl")):
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                try:
                    rows.append(json.loads(line))
                except Exception:
                    pass
    fb = pd.DataFrame(rows) if rows else pd.DataFrame()

    # Create a basic label column: 1 if human_decision == "approved", else 0; if missing, use ai_decision
    if not fb.empty:
        fb["label"] = fb["human_decision"].fillna(fb.get("ai_decision", "denied")).map(lambda x: 1 if str(x) == "approved" else 0)
    else:
        # no feedback â€“ we can still make a candidate equal to current baseline
        fb = pd.DataFrame(columns=["application_id", "label"])

    # Join on application_id if present in base_df
    if "application_id" in fb.columns and "application_id" in base_df.columns:
        train_df = base_df.merge(fb[["application_id", "label"]], on="application_id", how="left")
    else:
        train_df = base_df.copy()
        if "label" not in train_df.columns:
            train_df["label"] = None

    # Call ensure_model (it will train if needed). It returns model + feature list.
    model, feat = ensure_model(train_df, force_fit=True, label_col="label")

    # Save candidate job
    job_id = str(int(time.time()))
    meta = {
        "job_id": job_id,
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "features": feat,
        "train_rows": int(len(train_df)),
        "labels_present": int(train_df["label"].notna().sum()) if "label" in train_df.columns else 0
    }
    save_candidate_model_meta(job_id, meta)

    return JSONResponse({"ok": True, "job_id": job_id, "meta": meta})

@router.get("/v1/training/train/{job_id}/status")
def get_train_status(job_id: str):
    meta = load_candidate_meta(job_id)
    if meta is None:
        raise HTTPException(404, "job not found")
    # In this simple implementation, training is synchronous and done.
    meta = dict(meta)
    meta["status"] = "done"
    return JSONResponse(meta)

@router.post("/v1/training/promote")
def post_promote():
    # Promote the most recent candidate meta to production (copy meta + model).
    cand_jsons = sorted(glob.glob(os.path.join(TRAINED_DIR, "candidate_job_*.json")), reverse=True)
    cand_bins  = sorted(glob.glob(os.path.join(TRAINED_DIR, "candidate_job_*.joblib")), reverse=True)

    if not cand_jsons or not cand_bins:
        raise HTTPException(400, "no candidate found to promote")

    # The most recent prefix (they match on timestamp suffix)
    cand_json = cand_jsons[0]
    # find matching .joblib with same timestamp part
    stamp = os.path.splitext(os.path.basename(cand_json))[0].split("candidate_job_")[-1]
    match_bin = [b for b in cand_bins if b.endswith(f"{stamp}.joblib")]
    if not match_bin:
        raise HTTPException(500, "candidate model binary missing")
    cand_bin = match_bin[0]

    save_production_model(cand_bin, cand_json)
    return JSONResponse({"ok": True, "promoted": {"model": cand_bin, "meta": cand_json}})

@router.get("/v1/training/production_meta")
def get_production_meta():
    meta_path = os.path.join(PROD_DIR, "meta.json")
    if not os.path.isfile(meta_path):
        return JSONResponse({"has_production": False})
    try:
        with open(meta_path, "r", encoding="utf-8") as f:
            meta = json.load(f)
        return JSONResponse({"has_production": True, "meta": meta})
    except Exception:
        return JSONResponse({"has_production": False})
