# services/api/routers/training.py
from __future__ import annotations

import csv
import io
import os
import time
from typing import Any, Dict, List, Optional

import pandas as pd
from fastapi import APIRouter, HTTPException, Request

router = APIRouter(tags=["training"])

# Storage roots
THIS_DIR = os.path.abspath(os.path.dirname(__file__))
API_ROOT = os.path.abspath(os.path.join(THIS_DIR, ".."))
RUNS_ROOT = os.path.join(API_ROOT, ".runs")
FEEDBACK_DIR = os.path.join(RUNS_ROOT, "feedback")
TMP_DIR = os.path.join(RUNS_ROOT, "tmp")

os.makedirs(RUNS_ROOT, exist_ok=True)
os.makedirs(FEEDBACK_DIR, exist_ok=True)
os.makedirs(TMP_DIR, exist_ok=True)

# Import model utils from the agent package
try:
    from agents.credit_appraisal import model_utils as mu
except Exception as e:
    # Make this a hard error: the service can’t run without model utils
    raise RuntimeError(f"Failed to import model utils: {e}") from e


def _ts() -> str:
    return time.strftime("%Y%m%d-%H%M%S")


def _validate_feedback_csvs(paths: Optional[List[str]]) -> List[str]:
    if not paths:
        raise HTTPException(status_code=400, detail="`feedback_csvs` must be a non-empty list of CSV paths.")
    abs_paths: List[str] = []
    for p in paths:
        if not isinstance(p, str) or not p.strip():
            raise HTTPException(status_code=400, detail=f"Invalid path in feedback_csvs: {p!r}")
        ap = os.path.abspath(p)
        if not os.path.isfile(ap):
            raise HTTPException(status_code=400, detail=f"Feedback CSV does not exist: {ap}")
        abs_paths.append(ap)
    return abs_paths


@router.post("/v1/training/feedback")
async def post_feedback(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Collect human review feedback (from UI tab 4) and append to a dated CSV.
    Expected payload:
      {
        "items": [
          {
            "application_id": "...",
            "ai_decision": "approved|denied",
            "human_decision": "approved|denied",
            "human_rule_reasons": "... or JSON"
          },
          ...
        ]
      }
    """
    items = payload.get("items") or []
    if not isinstance(items, list) or not items:
        raise HTTPException(status_code=400, detail="`items` must be a non-empty list.")

    # Normalize to DataFrame, append minimal audit fields
    df = pd.DataFrame(items)
    df["received_at"] = _ts()

    # Write/append into a daily file so users can download and stage into training
    day_file = os.path.join(FEEDBACK_DIR, f"feedback-{_ts()[:8]}.csv")
    if os.path.exists(day_file):
        # append without header
        df.to_csv(day_file, mode="a", index=False, header=False)
    else:
        df.to_csv(day_file, index=False)

    return {"ok": True, "saved_to": day_file, "rows": int(len(df))}


@router.get("/v1/training/models")
async def list_models(kind: str = "trained") -> Dict[str, Any]:
    """
    List model registry.
      kind ∈ {"trained", "production"}
    """
    try:
        models = mu.list_available_models(kind=kind)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to list models: {e}") from e
    return {"kind": kind, "models": models}


@router.get("/v1/training/production_meta")
async def production_meta() -> Dict[str, Any]:
    """
    Return production model meta:
      {"has_production": bool, "meta": {...} | null}
    """
    try:
        return mu.get_production_meta()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e)) from e


@router.post("/v1/training/train")
async def train_candidate(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    New training API (contract enforced):
    {
      "feedback_csvs": ["/abs/path/to/feedback.csv", ...],
      "user_name": "Your Name",
      "agent_name": "credit_appraisal",
      "algo_name": "credit_lr"
    }
    """
    # Validate core contract (#1 and #3)
    feedback_csvs = _validate_feedback_csvs(payload.get("feedback_csvs"))
    user_name = payload.get("user_name")
    agent_name = payload.get("agent_name") or "credit_appraisal"
    algo_name = payload.get("algo_name") or "credit_lr"

    if not user_name or not isinstance(user_name, str):
        raise HTTPException(status_code=400, detail="`user_name` is required and must be a string.")

    try:
        result = mu.fit_candidate_on_feedback(
            feedback_csvs=feedback_csvs,
            user_name=user_name,
            agent_name=agent_name,
            algo_name=algo_name,
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Training failed: {e}") from e

    # Shape a clean response
    return {
        "job_id": result.get("job_id"),
        "model_name": result.get("model_name"),
        "model_path": result.get("model_path"),
        "meta_path": result.get("meta_path"),
        "metrics": result.get("metrics"),
        "feature_names": result.get("feature_names"),
    }


@router.post("/v1/training/promote")
async def promote(payload: Dict[str, Any] = None) -> Dict[str, Any]:
    """
    Promote a trained model to production.
    Payload:
      {"model_name": "credit_lr-username-credit_appraisal-YYYYMMDD-HHMMSS.joblib"}
    If omitted, promotes the most recently modified trained model.
    """
    model_name = None
    if payload and isinstance(payload, dict):
        model_name = payload.get("model_name")

    try:
        if not model_name:
            # choose latest by mtime
            trained_list = mu.list_available_models(kind="trained")
            if not trained_list:
                raise HTTPException(status_code=400, detail="No trained models available to promote.")
            # find latest file by mtime
            trained_dir = os.path.join(os.path.dirname(mu.PRODUCTION_MODEL_PATH), "trained")
            candidates = [os.path.join(trained_dir, f) for f in trained_list]
            latest = max(candidates, key=os.path.getmtime)
            model_name = os.path.basename(latest)

        out = mu.promote_to_production(model_name=model_name)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Promote failed: {e}") from e

    return {"ok": True, "promoted_model": model_name, **out}
